> **逆置顺序表中所有元素**
```c
bool ReverseList(SqList *L){    //逆置矩阵
    int front = 0;
    int rear = L->length-1;
    if(rear<=0)
        return false;
    while (rear-front>1)
    {
        int Temp = 0;
        Temp=L->data[front];
        L->data[front]=L->data[rear];
        L->data[rear]=Temp;
        front++;rear--;
    }
    return true;
}
```
> **将数组中的元素$(X,X,...,X_{n-1})$，经过移动后变为$(X_p,X_{p+1},...,X_{n-1},X_0,X_1,...,X_{p-1})$，即循环左移$p(0<p<n)$个位置。**

**分析：**
- 两次逆转就会恢复原序。
- 只需要将$0\sim p-1$位置的元素逆置，再将$p\sim n-1$位置的元素逆置，然后将整个数组逆置即可。

```c
bool ReversePList(int *arr,int left,int right)//指定范围逆置
{
    int Temp=0;
    while (right-left>0)
    {
        Temp=arr[left];
        arr[left]=arr[right];
        arr[right]=Temp;
        left++;
        right--;
    }
    return true;
}

void MoveP(int *arr,int n,int p){
    ReversePList(arr,0,p-1);
    ReversePList(arr,p, n-1);
    ReversePList(arr,0 ,n-1);
}
```

> **设顺序表用数组A[]表示，表中元素存储在数组下标0~m+n-1的范围内，后n个元素也递增有序，设计一个算法，使得整个顺序表有序。**
（1）给出算法的基本设计思想。
（2）根据设计思想，采用C或C++语言描述算法，并在关键之处给出注释。
（3）说明你所设计的算法的时间复杂度和空间复杂度。

(1)
- 将数组$A[]$中的 $m+n$ 个元素(假设元素为 int型)看成两个顺序表：表 L 和表 R。将数组当前状态看作起始状态，即此时表 L 由 $A[]$中前 m 个元素构成，表 R 由 $A[]$中后 n 个元素构成。要使 $A[]$中 $m+n$ 个元素整体有序，只需将表 R 中的元素逐个插入表 L 中的合适位置即可。
- 插入过程：取表 R 中的第一个元素 $A[m]$存入辅助变量 temp 中，让 temp 逐个与 $A[m-1], \cdots, A[0] $进行比较，当 $temp<A[j](0\leqslant j\leqslant m-1)$时，将 $A[j]$后移一位，否则将 temp 存入 $A[j+1]$中。重复上述过程， 继续插入 $A[m+1], A[m+2], \cdots, A[m+n-1]$, 最终 $A[]$中元素整体有序。

(2)

```c
void SortA1A2(int *a, int m, int n) {
    int i, j;
    int temp;
    for (i = m; i < m + n; i++) {
        temp = a[i];
        for (j = i; j > 0 && a[j - 1] > temp; j--) {
            a[j] = a[j - 1];
        }
        a[j] = temp;
    }
}
```
(3)算法的时间复杂度为O(mn)。算法所需额外存储空间与数据规模 m 和 n 无关，变化属于常量级，因此空间复杂度为O(1)。

> **设计一个算法，从一给定的顾序表L中删除下标$i\sim j(i\leqslant j,包括i、j)$的所有元素，假定$ i、j$都是合法的。**

```c
void DeleteI2J(SqList *L, int i,int j){
    while (j<L->length)
    {
        L->data[i++]=L->data[j++];
    }
    L->length=L->length+i-j-1;
}
```

> **有一个顺序表 L，其元素为整型数据，设计一个算法，将 L 中所有小于表头元素的整数放在前半部分，大于表头元素的整数放在后半部分。**

```c
void SortByHead(SqList *L)
{
    int i = 1, j = L->length - 1;
    int temp;
    while (j > i)
    { 
        while (i < j && L->data[i] < L->data[0])
            i++;
        while (i < j && L->data[j] > L->data[0])
            j--;
        if (i < j)
        {
            temp = L->data[i];
            L->data[i] = L->data[j];
            L->data[j] = temp;
            i++;
            j--;
        }
    }
    if (L->data[0] > L->data[j])
    {
        temp = L->data[0];
        L->data[0] = L->data[j];
        L->data[j] = temp;
    }
}
```
> **有一个递增非空单链表，设计一个算法删除值域重复的结点。例如，$\{1,1,2,3,3,3,4,4,4,7,7,7,9,9,9\}$经过删除后变成$\{1,2,3,4,7,9\}$。**



(7)设计一个算法删除单链表L(有头结点)中的一个最小值结点。