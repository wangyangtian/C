# 线性表
数据结构三要素——逻辑结构、数据的运算、存储结构（物理结构）


## 顺序表——用顺序存储的方式实现线性表

- $a_i$是第$i$个元素，称$i$为数据元素$a_i$在线性表中的位序。
- 每个数据元素所占空间一样大
- 逻辑上相邻的数据元素物理上也相邻
- 随机存取



### 顺序表的实现—————静态分配
```c
#define MAXSIZE 10  //定义最大长度

// 顺序表的实现—————静态分配

typedef struct Linear_list
{
    int data[MAXSIZE];  //使用静态数组
    int length;         //顺序表的当前长度
}SqList;                //顺序表的类型定义

void InitList(SqList* L){
    for (size_t i = 0; i < MAXSIZE; i++)
    {
        L->data[i]=0;
    }
    L->length=0;
}
```


### 顺序表的实现—————动态分配


```c
#define INITSIZE 10     //默认最大长度

typedef struct Linear_list_dynamic
{
    int* data;      //动态分配数组指针
    int MaxSize;    //顺序表的最大容量
    int Length;     //顺序表当前长度
}SqList;

void InitList(SqList* L){
    L->data=(int*)malloc(sizeof(int)*INITSIZE); //申请默认长度的空间
    if(!L->data)
        exit(EXIT_FAILURE);
    L->Length=0;
    L->MaxSize=INITSIZE;
}
```
**顺序表的特点：** 
1. 随机访问，即可以在 O(1) 时间内找到第 i 个元素。
2. 存储密度高，每个节点只存储数据元素
3. 拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）
4. 插入、删除操作不方便，需要移动大量元素


<big>**注意：**</big>
- 在ListInsert中出现的错误：
    + 位序index和数组下标差1，从L->data[i-1]移到L->data[i]
    + 判断插入位置是否合法，并给出相应的报错。
- 在LocateElem中出现的错误：
    + 把`    printf("Can not find it.");    return -1;    `放到循环中，导致只会判断第一个元素。
    + 返回和打印的位序应该是i+1。
    + c语言中，结构体的比较不能直接用"=="

## 链表

## 单链表
- 优点:不要求大片连续空间，改变容量方便
- 缺点:不可随机存取，要耗费一定空间存放指针

**不带头结点的初始化**

```c
bool InitList(LinkList *L)  //初始化一个空链表
                            //注意！！
                            //传入的是L的地址，因为要将L指向的空间修改为NULL
{
    L = NULL;
    return true;
}
```
**注意**
- 强调这是一个单链表————使用 LinkList
- 强调这是一个结点————使用LNode*

**带头结点的初始化**
```c
bool InitList(LinkList* L){
    *L=(LNode*)malloc(sizeof(LNode));       //分配一个头结点
    if (*L == NULL)                         //内存不足，分配失败
	{
		printf("内存空间不足，分配空间失败\n");
		return false;
	}
	(*L)->next = NULL;                      //头结点之后暂时没有节点
	return true;
}
```

为头指针单独定义一个结构体是否跟容易理解？

```c
typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct {
    Node* head;
} LinkList;

bool InitList(LinkList* L) {
    // 分配内存空间给头结点
    L->head = (Node*)malloc(sizeof(Node));
    if (L->head == NULL) {
        return false; // 内存分配失败，初始化失败
    }

    // 初始化头结点
    L->head->next = NULL;
    return true; // 初始化成功
}
```

**当时没有理解为什么要`j < i - 1`而不是`j < i`。**
- 当 `i = 1` 时，`i - 1 = 0`，我们需要找到第 `0` 个节点（头节点）。在这种情况下，`j` 初始值为 `0`，因此不需要进入循环，`p` 直接指向头节点，这样可以直接在头节点后插入新节点。
- 也就是说，想要在`i`处插入元素，就要将`p`指向节点`i - 1`。
- 指向`i - 1`的指针其实是`i - 2`的`next`指针。
- 所以`p = 'i-2'->next`


```C
    // 找到第i-1个节点
    while (p != NULL && j < i - 1) {
        p = p->next;
        j++;
    }
```
