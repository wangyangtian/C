> 为了充分利用空间，顺序栈 s0、s1 共享一个存储区 $elem[0, \cdots, maxSize-1]$。试设计共享栈 s0、s1 以及有关入栈和出栈操作的算法，假设栈中元素为 int 型。要求：
(1)给出基本设计思想。
(2)根据设计思想，采用 C 或 C++语言描述算法(对于共享栈要写出其结构定义),

```c
#define MAXSIZE 100  // 定义共享栈的最大容量

typedef struct {
    int elem[MAXSIZE];  // 共享栈的存储区
    int s0_top;  // 栈s0的栈顶指针
    int s1_top;  // 栈s1的栈顶指针
} SharedStack;

// 初始化共享栈
void initStack(SharedStack *stack) {
    stack->s0_top = -1;  // s0栈顶指针初始为-1
    stack->s1_top = MAXSIZE;  // s1栈顶指针初始为MAXSIZE
}

// 入栈操作
int push(SharedStack *stack, int stackNumber, int value) {
    if (stack->s0_top + 1 == stack->s1_top) {  // 判断栈是否满
        printf("Stack is full.\n");
        return -1;  // 入栈失败
    }
    if (stackNumber == 0) {  // s0入栈
        stack->elem[++(stack->s0_top)] = value;  // s0栈顶指针先加1，然后入栈
    } else if (stackNumber == 1) {  // s1入栈
        stack->elem[--(stack->s1_top)] = value;  // s1栈顶指针先减1，然后入栈
    } else {
        printf("Invalid stack number.\n");
        return -1;  // 入栈失败
    }
    return 0;  // 入栈成功
}

// 出栈操作
int pop(SharedStack *stack, int stackNumber, int *value) {
    if (stackNumber == 0) {  // s0出栈
        if (stack->s0_top == -1) {  // 判断栈是否空
            printf("Stack s0 is empty.\n");
            return -1;  // 出栈失败
        }
        *value = stack->elem[(stack->s0_top)--];  // 取出栈顶元素，栈顶指针减1
    } else if (stackNumber == 1) {  // s1出栈
        if (stack->s1_top == MAXSIZE) {  // 判断栈是否空
            printf("Stack s1 is empty.\n");
            return -1;  // 出栈失败
        }
        *value = stack->elem[(stack->s1_top)++];  // 取出栈顶元素，栈顶指针加1
    } else {
        printf("Invalid stack number.\n");
        return -1;  // 出栈失败
    }
    return 0;  // 出栈成功
}
```

> 请利用两个栈s1和s2来模拟一个队列，假设栈中元素为int型，栈假设栈中元素为maxSize。已知栈的 3个运算定义如下。
&emsp;push(ST,x):元素x入 ST 栈。
&emsp;pop(ST, &x):ST栈顶元素出栈，赋给变量x。
&emsp;isEmpty(ST):判断ST栈是否为空。
如何利用栈的运算来实现该队列的3个运算:enQueue（(元素入队列)、deQueue（元素出队列)、isQueueEmpty（判断队列是否为空，空返回1，不空返回0)。
要求∶
1）给出基本设计思想。
2）根据设计思想，采用C语言描述算法，关键之处给出注释

```c
void initQueue(Queue *queue) {
    queue->s1.top = -1;
    queue->s2.top = -1;
}

void enQueue(Queue *queue, int x) {
    push(&(queue->s1), x);
}

void deQueue(Queue *queue, int *x) {
    if (isEmpty(queue->s2)) {
        while (!isEmpty(queue->s1)) {
            int temp;
            pop(&(queue->s1), &temp);
            push(&(queue->s2), temp);
        }
    }
    if (!isEmpty(queue->s2)) {
        pop(&(queue->s2), x);
    } else {
        printf("Queue underflow\n");
    }
}

int isQueueEmpty(Queue queue) {
    return isEmpty(queue.s1) && isEmpty(queue.s2);
}
```

> 假设以I和O分别表示入栈和出栈操作。若栈的初态和终态均为空，入栈和出栈的操作序列可表示为仅由I和O组成的序列，则称可以操作的序列为合法序列，否则称为非法序列。
(1)试指出判别给定序列是否合法的一般规则。
(2)两个不同的合法序列(对两个具有同样元素的输入序列)能否得到相同的输出元素序列？如能得到，请举例说明。
(3)写出一个算法，判定所给的操作序列是否合法。若合法，返回 l,否则返回 0(假定被判定的操作序列已存入一维 char 型数组 ch[]中，操作序列以“0”为结束符)。
1) 通常有两条规则，第一条是给定序列中，I 的个数和 O 的个数相等；第二条是从给定序列的开始到给定序列中的任一位置，I 的个数要大于或等于 O 的个数。

2) 可以得到相同的输出元素序列。例如，输入元素为 A、B、C,则两个输入序列 A、B、C 和 B、 A、C 均可得到输出元素序列 A、B、C。对于输入序列 A、B、C,我们使用本题约定的 IOIOIO 操作序列；对于输入序列 B、A、C,我们使用IIOOIO 操作序列。

3) 由1)中分析可以写出以下代码：
```c
bool judge(char* ch) {
    int i = 0;
    int sign = 0;
    int count_I = 0, count_O = 0;
    while (ch[i] != '\0') {
        if (ch[i] == 'I') {
            sign++;
            count_I++;
        }
        if (ch[i] == 'O') {
            sign--;
            count_O++;
        }
        if (sign < 0)
            return false;
        i++;
    }
    if (count_I != count_O)
        return false;
    return true;
}
```
> 假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾结点，但不设头指针，请写出相应的入队列和出队列算法。

**最后一次出队记得修改`rear`指针！**
```c
// 队结点类型定义
typedef struct Linked_queue {
    int data;
    struct Linked_queue *next;
} LinkNode;

// 链队类型定义
typedef struct {
    LinkNode *rear;
} LinkQueue;

// 带头结点初始化
void InitQueue(LinkQueue *Q) {
    Q->rear = (LinkNode*)malloc(sizeof(LinkNode));
    Q->rear->next = Q->rear;  // 初始化为指向自己，形成循环
}

// 入队列
void EnQueue(LinkQueue *Q, int x) {
    LinkNode *p = (LinkNode*)malloc(sizeof(LinkNode));
    p->data = x;
    p->next = Q->rear->next;  // 新节点指向头结点
    Q->rear->next = p;  // 原尾结点指向新节点
    Q->rear = p;  // 尾指针指向新节点
}

// 出队列
void DeQueue(LinkQueue *Q, int *x) {
    if (Q->rear->next == Q->rear) return;  // 队列为空
    LinkNode *head = Q->rear->next;
    LinkNode *tp = head->next;
    *x = tp->data;
    head->next = tp->next;
    if (Q->rear == tp) Q->rear = head;  // 若队列只有一个元素，出队后要调整rear
    free(tp);
}
```
> 如果允许在循环队列的两端都可以进行插入和删除操作，要求：
&emsp;(1)写出循环队列的类型定义。
&emsp;(2)分别写出从队尾删除和从队头插入的算法。

```c
typedef struct CircularQueue
{
    int data;
    struct CircularQueue *next;
    struct CircularQueue *prior;
}CQNode;

typedef struct 
{
    CQNode *front;
    CQNode *rear;
}CQueue;

void InitQueue(CQueue *cq){
    cq->front=cq->rear=(CQNode*)malloc(sizeof(CQNode));
    cq->front->next=cq->front;
    cq->front->prior=cq->rear;
}

void TailDelete(CQueue *cq,int *x){
    if (cq->rear == cq->front) return;  // 队列为空
    CQNode *p=cq->rear;
    *x = p->data;
    p->prior->next=p->next;
    p->next->prior=p->prior;
    cq->rear=p->prior;
    free(p);
}

void HeadInsert(CQueue *cq,int x){
    CQNode * q=(CQNode*)malloc(sizeof(CQNode));
    q->data=x;
    q->next = cq->front->next;
    cq->front->next->prior = q;
    cq->front->next = q;
    q->prior = cq->front;
    if (cq->front == cq->rear) {
        cq->rear = q;  // 插入第一个元素时需要更新rear
 
```
